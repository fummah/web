{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { omit } from \"./utils.js\";\nexport function getIndexId(context) {\n  return hasMultipleIndices(context) ? context.multiIndexContext.targetedIndex : context.ais.mainTargetedIndex;\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @returns {import('algoliasearch-helper').SearchResults} results\n */\nexport function getResults(searchResults, context) {\n  if (searchResults.results) {\n    if (searchResults.results.hits) {\n      return searchResults.results;\n    }\n    var indexId = getIndexId(context);\n    if (searchResults.results[indexId]) {\n      return searchResults.results[indexId];\n    }\n  }\n  return null;\n}\nexport function hasMultipleIndices(context) {\n  return context && context.multiIndexContext;\n}\nexport function refineValue(searchState, nextRefinement, context, resetPage, namespace) {\n  if (hasMultipleIndices(context)) {\n    var indexId = getIndexId(context);\n    return namespace ? refineMultiIndexWithNamespace(searchState, nextRefinement, indexId, resetPage, namespace) : refineMultiIndex(searchState, nextRefinement, indexId, resetPage);\n  } else {\n    // When we have a multi index page with shared widgets we should also\n    // reset their page to 1 if the resetPage is provided. Otherwise the\n    // indices will always be reset\n    // see: https://github.com/algolia/react-instantsearch/issues/310\n    // see: https://github.com/algolia/react-instantsearch/issues/637\n    if (searchState.indices && resetPage) {\n      Object.keys(searchState.indices).forEach(function (targetedIndex) {\n        searchState = refineValue(searchState, {\n          page: 1\n        }, {\n          multiIndexContext: {\n            targetedIndex: targetedIndex\n          }\n        }, true, namespace);\n      });\n    }\n    return namespace ? refineSingleIndexWithNamespace(searchState, nextRefinement, resetPage, namespace) : refineSingleIndex(searchState, nextRefinement, resetPage);\n  }\n}\nfunction refineMultiIndex(searchState, nextRefinement, indexId, resetPage) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  var state = searchState.indices && searchState.indices[indexId] ? _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread(_objectSpread({}, searchState.indices[indexId]), nextRefinement), page))) : _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, nextRefinement), page)));\n  return _objectSpread(_objectSpread({}, searchState), {}, {\n    indices: state\n  });\n}\nfunction refineSingleIndex(searchState, nextRefinement, resetPage) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  return _objectSpread(_objectSpread(_objectSpread({}, searchState), nextRefinement), page);\n}\nfunction refineMultiIndexWithNamespace(searchState, nextRefinement, indexId, resetPage, namespace) {\n  var _objectSpread4;\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  var state = searchState.indices && searchState.indices[indexId] ? _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, searchState.indices[indexId]), {}, (_objectSpread4 = {}, _defineProperty(_objectSpread4, namespace, _objectSpread(_objectSpread({}, searchState.indices[indexId][namespace]), nextRefinement)), _defineProperty(_objectSpread4, \"page\", 1), _objectSpread4)))) : _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_defineProperty({}, namespace, nextRefinement), page)));\n  return _objectSpread(_objectSpread({}, searchState), {}, {\n    indices: state\n  });\n}\nfunction refineSingleIndexWithNamespace(searchState, nextRefinement, resetPage, namespace) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  return _objectSpread(_objectSpread({}, searchState), {}, _defineProperty({}, namespace, _objectSpread(_objectSpread({}, searchState[namespace]), nextRefinement)), page);\n}\nfunction getNamespaceAndAttributeName(id) {\n  var parts = id.match(/^([^.]*)\\.(.*)/);\n  var namespace = parts && parts[1];\n  var attributeName = parts && parts[2];\n  return {\n    namespace: namespace,\n    attributeName: attributeName\n  };\n}\nfunction hasRefinements(_ref) {\n  var multiIndex = _ref.multiIndex,\n    indexId = _ref.indexId,\n    namespace = _ref.namespace,\n    attributeName = _ref.attributeName,\n    id = _ref.id,\n    searchState = _ref.searchState;\n  if (multiIndex && namespace) {\n    return searchState.indices && searchState.indices[indexId] && searchState.indices[indexId][namespace] && Object.hasOwnProperty.call(searchState.indices[indexId][namespace], attributeName);\n  }\n  if (multiIndex) {\n    return searchState.indices && searchState.indices[indexId] && Object.hasOwnProperty.call(searchState.indices[indexId], id);\n  }\n  if (namespace) {\n    return searchState[namespace] && Object.hasOwnProperty.call(searchState[namespace], attributeName);\n  }\n  return Object.hasOwnProperty.call(searchState, id);\n}\nfunction getRefinements(_ref2) {\n  var multiIndex = _ref2.multiIndex,\n    indexId = _ref2.indexId,\n    namespace = _ref2.namespace,\n    attributeName = _ref2.attributeName,\n    id = _ref2.id,\n    searchState = _ref2.searchState;\n  if (multiIndex && namespace) {\n    return searchState.indices[indexId][namespace][attributeName];\n  }\n  if (multiIndex) {\n    return searchState.indices[indexId][id];\n  }\n  if (namespace) {\n    return searchState[namespace][attributeName];\n  }\n  return searchState[id];\n}\nexport function getCurrentRefinementValue(props, searchState, context, id, defaultValue) {\n  var indexId = getIndexId(context);\n  var _getNamespaceAndAttri = getNamespaceAndAttributeName(id),\n    namespace = _getNamespaceAndAttri.namespace,\n    attributeName = _getNamespaceAndAttri.attributeName;\n  var multiIndex = hasMultipleIndices(context);\n  var args = {\n    multiIndex: multiIndex,\n    indexId: indexId,\n    namespace: namespace,\n    attributeName: attributeName,\n    id: id,\n    searchState: searchState\n  };\n  var hasRefinementsValue = hasRefinements(args);\n  if (hasRefinementsValue) {\n    return getRefinements(args);\n  }\n  if (props.defaultRefinement) {\n    return props.defaultRefinement;\n  }\n  return defaultValue;\n}\nexport function cleanUpValue(searchState, context, id) {\n  var indexId = getIndexId(context);\n  var _getNamespaceAndAttri2 = getNamespaceAndAttributeName(id),\n    namespace = _getNamespaceAndAttri2.namespace,\n    attributeName = _getNamespaceAndAttri2.attributeName;\n  if (hasMultipleIndices(context) && Boolean(searchState.indices)) {\n    return cleanUpValueWithMultiIndex({\n      attribute: attributeName,\n      searchState: searchState,\n      indexId: indexId,\n      id: id,\n      namespace: namespace\n    });\n  }\n  return cleanUpValueWithSingleIndex({\n    attribute: attributeName,\n    searchState: searchState,\n    id: id,\n    namespace: namespace\n  });\n}\nfunction cleanUpValueWithSingleIndex(_ref3) {\n  var searchState = _ref3.searchState,\n    id = _ref3.id,\n    namespace = _ref3.namespace,\n    attribute = _ref3.attribute;\n  if (namespace) {\n    return _objectSpread(_objectSpread({}, searchState), {}, _defineProperty({}, namespace, omit(searchState[namespace], [attribute])));\n  }\n  return omit(searchState, [id]);\n}\nfunction cleanUpValueWithMultiIndex(_ref4) {\n  var searchState = _ref4.searchState,\n    indexId = _ref4.indexId,\n    id = _ref4.id,\n    namespace = _ref4.namespace,\n    attribute = _ref4.attribute;\n  var indexSearchState = searchState.indices[indexId];\n  if (namespace && indexSearchState) {\n    return _objectSpread(_objectSpread({}, searchState), {}, {\n      indices: _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, indexSearchState), {}, _defineProperty({}, namespace, omit(indexSearchState[namespace], [attribute])))))\n    });\n  }\n  if (indexSearchState) {\n    return _objectSpread(_objectSpread({}, searchState), {}, {\n      indices: _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, omit(indexSearchState, [id])))\n    });\n  }\n  return searchState;\n}","map":null,"metadata":{},"sourceType":"module"}