{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nexports.__esModule = true;\nvar React = require(\"react\");\nvar placeholders = require(\"./placeholders\");\nvar utils_1 = require(\"./utils\");\nvar ReactPlaceholder = function (_a) {\n  var _b = _a.delay,\n    delay = _b === void 0 ? 0 : _b,\n    _c = _a.type,\n    type = _c === void 0 ? 'text' : _c,\n    _d = _a.color,\n    color = _d === void 0 ? '#CDCDCD' : _d,\n    _e = _a.rows,\n    rows = _e === void 0 ? 3 : _e,\n    readyProp = _a.ready,\n    firstLaunchOnly = _a.firstLaunchOnly,\n    children = _a.children,\n    className = _a.className,\n    showLoadingAnimation = _a.showLoadingAnimation,\n    customPlaceholder = _a.customPlaceholder,\n    rest = __rest(_a, [\"delay\", \"type\", \"color\", \"rows\", \"ready\", \"firstLaunchOnly\", \"children\", \"className\", \"showLoadingAnimation\", \"customPlaceholder\"]);\n  var _f = React.useState(readyProp),\n    ready = _f[0],\n    setReady = _f[1];\n  var timeout = React.useRef(null);\n  var getFiller = function () {\n    var classes = showLoadingAnimation ? utils_1.joinClassNames('show-loading-animation', className) : className;\n    if (customPlaceholder && React.isValidElement(customPlaceholder)) {\n      var mergedCustomClasses = utils_1.joinClassNames(customPlaceholder.props.className, classes);\n      return React.cloneElement(customPlaceholder, {\n        className: mergedCustomClasses\n      });\n    } else if (customPlaceholder) {\n      return customPlaceholder;\n    }\n    var Placeholder = placeholders[type];\n    return React.createElement(Placeholder, __assign({}, rest, {\n      color: color,\n      rows: rows,\n      className: classes\n    }));\n  };\n  React.useEffect(function () {\n    if (!firstLaunchOnly && ready && !readyProp) {\n      if (delay && delay > 0) {\n        timeout.current = window.setTimeout(function () {\n          setReady(false);\n        }, delay);\n      } else {\n        setReady(false);\n      }\n    } else if (readyProp) {\n      if (timeout.current) {\n        window.clearTimeout(timeout.current);\n      }\n      if (!ready) {\n        setReady(true);\n      }\n    }\n  }, [firstLaunchOnly, ready, readyProp, delay]);\n  // clear the timeout when the component unmounts\n  React.useEffect(function () {\n    return function () {\n      if (timeout.current) {\n        window.clearTimeout(timeout.current);\n      }\n    };\n  }, []);\n  // Casting - workaround for DefinitelyTyped/react issue with\n  // FunctionComponents returning ReactElement, where they should be able to\n  // return ReactNode. Casting also doesn't introduce another layer in the\n  // component tree like another `<>children</>` workaround does.\n  //\n  // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/33006\n  // and https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n  return ready ? children : getFiller();\n};\nexports[\"default\"] = ReactPlaceholder;","map":null,"metadata":{},"sourceType":"script"}