{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport PropTypes from 'prop-types';\nimport createConnector from \"../core/createConnector.js\";\nimport { cleanUpValue, refineValue, getCurrentRefinementValue, getResults, getIndexId } from \"../core/indexUtils.js\";\nimport { find } from \"../core/utils.js\";\nfunction stringifyItem(item) {\n  if (typeof item.start === 'undefined' && typeof item.end === 'undefined') {\n    return '';\n  }\n  var start = typeof item.start !== 'undefined' ? item.start : '';\n  var end = typeof item.end !== 'undefined' ? item.end : '';\n  return \"\".concat(start, \":\").concat(end);\n}\nfunction parseItem(value) {\n  if (value.length === 0) {\n    return {\n      start: null,\n      end: null\n    };\n  }\n  var _value$split = value.split(':'),\n    _value$split2 = _slicedToArray(_value$split, 2),\n    startStr = _value$split2[0],\n    endStr = _value$split2[1];\n  return {\n    start: startStr.length > 0 ? parseFloat(startStr) : null,\n    end: endStr.length > 0 ? parseFloat(endStr) : null\n  };\n}\nvar namespace = 'multiRange';\nfunction getId(props) {\n  return props.attribute;\n}\nfunction getCurrentRefinement(props, searchState, context) {\n  return getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), '', function (currentRefinement) {\n    if (currentRefinement === '') {\n      return '';\n    }\n    return currentRefinement;\n  });\n}\nfunction isRefinementsRangeIncludesInsideItemRange(stats, start, end) {\n  return stats.min >= start && stats.min <= end || stats.max >= start && stats.max <= end;\n}\nfunction isItemRangeIncludedInsideRefinementsRange(stats, start, end) {\n  return start >= stats.min && start <= stats.max || end >= stats.min && end <= stats.max;\n}\nfunction itemHasRefinement(attribute, results, value) {\n  var stats = results.getFacetByName(attribute) ? results.getFacetStats(attribute) : null;\n  var range = value.split(':');\n  var start = Number(range[0]) === 0 || value === '' ? Number.NEGATIVE_INFINITY : Number(range[0]);\n  var end = Number(range[1]) === 0 || value === '' ? Number.POSITIVE_INFINITY : Number(range[1]);\n  return !(Boolean(stats) && (isRefinementsRangeIncludesInsideItemRange(stats, start, end) || isItemRangeIncludedInsideRefinementsRange(stats, start, end)));\n}\nfunction _refine(props, searchState, nextRefinement, context) {\n  var nextValue = _defineProperty({}, getId(props, searchState), nextRefinement);\n  var resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n\n/**\n * connectNumericMenu connector provides the logic to build a widget that will\n * give the user the ability to select a range value for a numeric attribute.\n * Ranges are defined statically.\n * @name connectNumericMenu\n * @requirements The attribute passed to the `attribute` prop must be holding numerical values.\n * @kind connector\n * @propType {string} attribute - the name of the attribute in the records\n * @propType {{label: string, start: number, end: number}[]} items - List of options. With a text label, and upper and lower bounds.\n * @propType {string} [defaultRefinement] - the value of the item selected by default, follow the shape of a `string` with a pattern of `'{start}:{end}'`.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied.  follow the shape of a `string` with a pattern of `'{start}:{end}'` which corresponds to the current selected item. For instance, when the selected item is `{start: 10, end: 20}`, the searchState of the widget is `'10:20'`. When `start` isn't defined, the searchState of the widget is `':{end}'`, and the same way around when `end` isn't defined. However, when neither `start` nor `end` are defined, the searchState is an empty string.\n * @providedPropType {array.<{isRefined: boolean, label: string, value: string, isRefined: boolean, noRefinement: boolean}>} items - the list of ranges the NumericMenu can display.\n */\nexport default createConnector({\n  displayName: 'AlgoliaNumericMenu',\n  $$type: 'ais.numericMenu',\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    items: PropTypes.arrayOf(PropTypes.shape({\n      label: PropTypes.node,\n      start: PropTypes.number,\n      end: PropTypes.number\n    })).isRequired,\n    transformItems: PropTypes.func\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attribute = props.attribute;\n    var currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var items = props.items.map(function (item) {\n      var value = stringifyItem(item);\n      return {\n        label: item.label,\n        value: value,\n        isRefined: value === currentRefinement,\n        noRefinement: results ? itemHasRefinement(getId(props), results, value) : false\n      };\n    });\n    var stats = results && results.getFacetByName(attribute) ? results.getFacetStats(attribute) : null;\n    var refinedItem = find(items, function (item) {\n      return item.isRefined === true;\n    });\n    if (!items.some(function (item) {\n      return item.value === '';\n    })) {\n      items.push({\n        value: '',\n        isRefined: refinedItem === undefined,\n        noRefinement: !stats,\n        label: 'All'\n      });\n    }\n    var transformedItems = props.transformItems ? props.transformItems(items) : items;\n    return {\n      items: transformedItems,\n      currentRefinement: currentRefinement,\n      canRefine: transformedItems.length > 0 && transformedItems.some(function (item) {\n        return item.noRefinement === false;\n      })\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var attribute = props.attribute;\n    var _parseItem = parseItem(getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      })),\n      start = _parseItem.start,\n      end = _parseItem.end;\n    searchParameters = searchParameters.addDisjunctiveFacet(attribute);\n    if (typeof start === 'number') {\n      searchParameters = searchParameters.addNumericRefinement(attribute, '>=', start);\n    }\n    if (typeof end === 'number') {\n      searchParameters = searchParameters.addNumericRefinement(attribute, '<=', end);\n    }\n    return searchParameters;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var id = getId(props);\n    var value = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var items = [];\n    var index = getIndexId({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    if (value !== '') {\n      var _find = find(props.items, function (item) {\n          return stringifyItem(item) === value;\n        }),\n        label = _find.label;\n      items.push({\n        label: \"\".concat(props.attribute, \": \").concat(label),\n        attribute: props.attribute,\n        currentRefinement: label,\n        value: function value(nextState) {\n          return _refine(props, nextState, '', {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue\n          });\n        }\n      });\n    }\n    return {\n      id: id,\n      index: index,\n      items: items\n    };\n  }\n});","map":null,"metadata":{},"sourceType":"module"}